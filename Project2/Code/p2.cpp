#include <iostream>#include "p2.h"#include <cstdlib>using namespace std;int main(){    cout << "Hellow world" << endl;}// Here is the code for debugging//static bool list_equal(list_t l1, list_t l2) {//    if (list_isEmpty(l1) && list_isEmpty(l2)) {//        return true;//    } else if (list_isEmpty(l1) || list_isEmpty(l2)) {//        return false;//    } else if (list_first(l1) != list_first(l2)) {//        return false;//    } else {//        return list_equal(list_rest(l1), list_rest(l2));//    }//}////int main() {//    int i;//    list_t listA, listA_answer;//    list_t listB, listB_answer;////    listA = list_make();//    listB = list_make();//    listA_answer = list_make();//    listB_answer = list_make();////    for (i = 5; i > 0; i--) {//        listA = list_make(i, listA);//        listA_answer = list_make(6 - i, listA_answer);//        listB = list_make(i + 10, listB);//        listB_answer = list_make(i + 10, listB_answer);//    }////    for (i = 5; i > 0; i--) {//        listB_answer = list_make(i, listB_answer);//    }////    list_print(listA);//    cout << endl;//    list_print(listB);//    cout << endl;////    listB = append(listA, listB);//    listA = reverse(listA);//    list_print(listA);//    cout << endl;//    list_print(listB);//    cout << endl;////    list_print(listA);//    list_print(reverse(listA));//    cout<< endl//    cout << list_rest(listA) << endl;//    cout << dot(listA, listA) << endl;//    cout << size(listA) << endl;//    cout << memberOf(listA, 5) << endl;//    cout << isIncreasing(reverse(listA)) << endl;//    list_print(filter_odd(listA));//    cout << endl;//    cout << isArithmeticSequence(listA);////    listA = list_make(1,listA);//    list_print(listA);//    list_print(unique(listA));//    list_print(insert_list(listA,listA,2));////    list_print(chop(listA,3));//    if (list_equal(listA, listA_answer)//        && list_equal(listB, listB_answer)) {//        cout << "Success!\n";//        return 0;//    } else {//        cout << "Failed\n";//        return -1;//    }//}//Here stops the code for debugging.//static bool tree_equal(tree_t t1, tree_t t2)// EFFECTS: returns true iff t1 == t2//{//    if(tree_isEmpty(t1) && tree_isEmpty(t2))//    {//        return true;//    }//    else if(tree_isEmpty(t1) || tree_isEmpty(t2))//    {//        return false;//    }//    else//    {//        return ((tree_elt(t1) == tree_elt(t2))//                && tree_equal(tree_left(t1), tree_left(t2))//                && tree_equal(tree_right(t1), tree_right(t2)));//    }//}////int main()//{//    tree_t start = tree_make(2,//                             tree_make(1, tree_make(), tree_make()),//                             tree_make(4, tree_make(), tree_make()));//    tree_t end = tree_make(2,//                           tree_make(1, tree_make(), tree_make()),//                           tree_make(4,//                                     tree_make(3, tree_make(), tree_make()),//                                     tree_make()));//    tree_t cover1 = tree_make(2,//                              tree_make(),tree_make(4,tree_make(),tree_make())////    );//    tree_t cover2 = tree_make(4,tree_make(3,tree_make(),tree_make()),tree_make());//    tree_print(end);//    tree_print(start);//    tree_t candidate = insert_tree(3, start);//    tree_print(end);//    cout << endl;//    cout << endl;////    tree_print(candidate);//    cout << endl;////    cout << tree_sum(end) <<endl;//    cout<<tree_search(end,2)<<endl;//    cout<<tree_search(end,5)<<endl;//    cout <<depth(end) <<endl;//    cout<<tree_max(end)<<endl;//    list_print(traversal(end));//    cout<< tree_hasMonotonicPath(end)<<endl;//    cout <<tree_allPathSumGreater(end,1)<<endl;//    cout << tree_allPathSumGreater(end,3)<< endl;//    cout<< covered_by(cover1,end);//    cout<< covered_by(end,cover1);//    cout << contained_by(end,cover2) << endl;//    cout << contained_by(cover2,end) << endl;//    cout << covered_by(end, end) << endl;//    if(tree_equal(candidate, end))//    {//        cout << "Success!\n";//        return 0;//    }//    else//    {//        cout << "Failed\n";//        return -1;//    }////}int size(list_t list) {    if (list_isEmpty(list)) {        return 0;    } else {        return size(list_rest(list)) + 1;    }}bool memberOf(list_t list, int Val) {    if (list_isEmpty(list) == 1) return false;    else {        if (list_first(list) == Val) return true;        else return memberOf(list_rest(list), Val);    }}static int dot_helper(list_t v1, list_t v2, int Val) {    if (list_isEmpty(v1) || list_isEmpty(v2)) return Val;    else return dot_helper(list_rest(v1), list_rest(v2), Val + list_first(v1) * list_first(v2));}int dot(list_t v1, list_t v2) {    return dot_helper(v1, v2, 0);}bool isIncreasing(list_t v) {    if (size(v) < 2) return true;    else {        if (list_first(v) < list_first(list_rest(v))) return isIncreasing(list_rest(v));        else return false;    }}static list_t reverse_helper(list_t list, list_t rest) {    if (list_isEmpty(list)) return rest;    else return reverse_helper(list_rest(list), append(list_make(list_first(list), list_make()), rest));}list_t reverse(list_t list) {    list_t rest = list_make();    return reverse_helper(list, rest);}list_t append(list_t first, list_t second) {    if (list_isEmpty(first)) return second;    else return list_make(list_first(first), append(list_rest(first), second));}bool isArithmeticSequence(list_t v) {    if (list_isEmpty(v)) return true;    else if (size(v) == 1) return true;    else if (size(v) == 2) return true;    else {        return list_first(v) - list_first(list_rest(v)) ==               list_first(list_rest(v)) - list_first(list_rest(list_rest(v))) ? isArithmeticSequence(list_rest(v))                                                                              : false;    }}static list_t filter_odd_helper(list_t first, list_t second) {    if (list_isEmpty(first)) return second;    if (list_first(first) % 2 == 0) return filter_odd_helper(list_rest(first), list_make(list_first(first), second));    else return filter_odd_helper(list_rest(first), second);}list_t filter_odd(list_t list) {    list_t second2 = list_make();    return filter_odd_helper(list, second2);}static list_t filter_helper(list_t first, list_t second, bool (*fn)(int)) {    if (list_isEmpty(first)) return second;    if (fn(list_first(first))) return filter_helper(list_rest(first), list_make(list_first(first), second), (fn));    else return filter_helper(list_rest(first), second, (fn));}list_t filter(list_t list, bool (*fn)(int)) {    if (list_isEmpty(list)) return list_make();    else return filter_helper(list, list_make(), fn);}static list_t unique_helper(list_t first, list_t second, list_t third) {//    EFFECTS: first is the original list. List second is used to store the unique numbers, List third is used to compare.    if (list_isEmpty(first)) return second;    if (list_isEmpty(second))        return unique_helper(list_rest(first), list_make(list_first(first), list_make()),                             list_make(list_first(first), list_make()));    if (!list_isEmpty(third)) {        if (list_first(first) == list_first(third)) return unique_helper(list_rest(first), second, second);        else return unique_helper(first, second, list_rest(third));    } else        return unique_helper(list_rest(first), list_make(list_first(first), second),                             list_make(list_first(first), second));}list_t unique(list_t list) {    if (list_isEmpty(list)) return list_make();    else {        return reverse(unique_helper(list, list_make(), list_make()));    }}//static list_t insert_list_helper()//list_t insert_list(list_t first, list_t second, unsigned int n) {//    if (size(first) - n > 0)//        return insert_list(list_rest(first), reverse(list_make(list_first(reverse(first)), reverse(second))), n);//    else return append(first, second);//}list_t insert_list_helper(list_t first, list_t second, unsigned int n) {    return n == 0 ? append(first, second) : insert_list_helper(first, list_rest(second), n - 1);}list_t insert_list(list_t first, list_t second, unsigned int n) {    return insert_list_helper(append(chop(first, n), second), first, n);}static list_t chop_helper(list_t first, list_t second, int n) {    return n > 0 ? chop_helper(list_rest(first), reverse(list_make(list_first(first), reverse(second))), n - 1)                 : second;}list_t chop(list_t list, unsigned int n) {    list_t list2 = list_make();    return chop_helper(list, list2, n);}int tree_sum(tree_t tree) {    if (tree_isEmpty(tree)) return 0;    else return tree_elt(tree) + tree_sum(tree_left(tree)) + tree_sum(tree_right(tree));}bool tree_search(tree_t tree, int val) {    if (tree_isEmpty(tree)) return false;    else if (tree_elt(tree) == val) return true;    else if (tree_search(tree_left(tree), val)) return true;    else if (tree_search(tree_right(tree), val)) return true;    else return false;//    else if (tree_elt(tree)==val) return true;//    else return tree_search(tree_left(tree),val);}static int Max(int a, int b) {    return a > b ? a : b;}int depth(tree_t tree) {    if (tree_isEmpty(tree)) return 0;    return 1 + Max(depth(tree_right(tree)), depth(tree_left(tree)));}static int tree_max_helper(tree_t tree, int max) {    if (tree_isEmpty(tree)) return max;    if (tree_elt(tree) > max)        return Max(tree_max_helper(tree_left(tree), tree_elt(tree)), tree_max_helper(tree_right(tree), tree_elt(tree)));    else return Max(tree_max_helper(tree_left(tree), max), tree_max_helper(tree_right(tree), max));}int tree_max(tree_t tree) {    return tree_max_helper(tree, tree_elt(tree));}list_t traversal(tree_t tree) {    if (tree_isEmpty(tree)) return list_make();    else return append(traversal(tree_left(tree)), list_make(tree_elt(tree), traversal(tree_right(tree))));}static bool tree_hasMonotonicPath_increasing(tree_t tree) {    if (tree_isEmpty(tree)) return true;    if (depth(tree) == 1) return true;    else if (tree_elt(tree) <= tree_elt(tree_left(tree))) return tree_hasMonotonicPath_increasing(tree_left(tree));    else if (tree_elt(tree) <= tree_elt(tree_right(tree))) return tree_hasMonotonicPath_increasing(tree_right(tree));    else return false;}static bool tree_hasMonotonicPath_decreasing(tree_t tree) {    if (tree_isEmpty(tree)) return true;    if (depth(tree) == 1) return true;    else if (tree_elt(tree) >= tree_elt(tree_left(tree))) return tree_hasMonotonicPath_decreasing(tree_left(tree));    else if (tree_elt(tree) >= tree_elt(tree_right(tree))) return tree_hasMonotonicPath_decreasing(tree_left(tree));    else return false;}bool tree_hasMonotonicPath(tree_t tree) {    return tree_hasMonotonicPath_decreasing(tree) || tree_hasMonotonicPath_increasing(tree);}static bool tree_allPathSumGreaterHelper(tree_t tree, int sum, int ans)//        Sum indicates the designed sum and ans indicates the answer for current step.s{    if (tree_isEmpty(tree)) {        return (ans > sum);    }    return (tree_allPathSumGreaterHelper(tree_left(tree), sum, ans + tree_elt(tree)) &&            tree_allPathSumGreaterHelper(tree_right(tree), sum, ans + tree_elt(tree)));//        return true;//    else return false;}bool tree_allPathSumGreater(tree_t tree, int sum) {    return tree_allPathSumGreaterHelper(tree, sum, 0);}bool covered_by(tree_t A, tree_t B) {    if ((tree_isEmpty(A) && !tree_isEmpty(B)) || (tree_isEmpty(A) && tree_isEmpty(B))) return true;    if (!tree_isEmpty(A) && tree_isEmpty(B)) return false;    if (tree_elt(A) == tree_elt(B)) {        return covered_by(tree_left(A), tree_left(B)) && covered_by(tree_right(A), tree_right(B));    } else return false;}bool contained_by(tree_t A, tree_t B) {    if (depth(A) > depth(B)) return false;    else if (tree_elt(A) == tree_elt(B)) return covered_by(A, B);    else return contained_by(A, tree_left(B)) || contained_by(A, tree_right(B));}bool is_symmetric(tree_t tree) {    if (tree_isEmpty(tree)) return 1;    else if (tree_elt(tree_left(tree_right(tree))) == tree_elt(tree_right(tree_left(tree))) &&             tree_elt(tree_left(tree_left(tree))) == tree_elt(tree_right(tree_right(tree))))        return is_symmetric(tree_left(tree)) && is_symmetric(tree_right(tree));    else return false;}//static tree_t insert_tree_helper(int elt, tree_t tree, int is_changed){//    if (tree_isEmpty((tree))) return  tree_make(elt,tree_make(),tree_make());//    if(is_changed==0) {//        return tree_elt(tree_left(tree))>elt? insert_tree(elt, tree_left(tree)):insert_tree(elt,tree_right(tree));//    }//    if(is_changed==1) {//        return tree_make()//    }//        if (tree_elt(tree_left(tree) )>elt) return tree_make(elt, insert_tree_helper(elt,tree_left(tree),is_changed), tree_right(tree));//    else return tree_make(elt,tree_left(tree),insert_tree_helper(elt, tree_right(tree), is_changed));//}tree_t insert_tree(int elt, tree_t tree) {    if (tree_isEmpty(tree)) return tree_make(elt, tree_make(), tree_make());    else        return (elt < tree_elt(tree)) ? tree_make(tree_elt(tree), insert_tree(elt, tree_left(tree)), tree_right(tree))                                      : tree_make(tree_elt(tree), tree_left(tree), insert_tree(elt, tree_right(tree)));}